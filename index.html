<!doctype html> 
<html lang="en"> 
<head> 
	<meta charset="UTF-8" />
    <meta http-equiv="cache-control" content="max-age=0" />
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="expires" content="0" />
<meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
<meta http-equiv="pragma" content="no-cache" />
	<title>yam3</title>
	
    <script type="text/javascript" src="js/phaser.min.js"></script>
    <script type="text/javascript" src="js/Block.js"></script>

    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

    var game = new Phaser.Game(640, 480, Phaser.AUTO, '', { preload: preload, create: create, update: update, render: render});
    var blocksStartX = 20;
    var blocksStartY = 20;
    var blockPadding = 5;
    var blockSize = 64; 
    var blocksHigh = 5;
    var blocksWide = 6;

    var score = 0;
    var currentTile;
    var blocksArray = []; // blocksArray[(y * blocksWide) + x]

    var seed = new Date().getTime();
    var randomBlocks = new Phaser.RandomDataGenerator([seed]);

function preload() {
	//  This sets a limit on the up-scale
    //game.scale.maxWidth = 800; 
    //game.scale.maxHeight = 600;
    
    //Set Scaling Mode
    //game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;

    //Load images
	game.load.spritesheet('blocks', 'img/blocks.png', blockSize, blockSize); 
}

function create() {

    blocksGroup = game.add.group();

    for (y = 0; y < blocksHigh; y++) {
        for (x = 0; x < blocksWide; x++) {
            //var block = game.add.sprite(, 'blocks', 1);
            //block = blocksGroup.create(, , 'blocks', );

            block = new Phaser.Sprite(game, (x*(blockSize+blockPadding))+blocksStartX, (y*(blockSize+blockPadding))+blocksStartY,
                'blocks', randomBlocks.integerInRange(1,5))
            game.add.existing(block);

            // Enable input.
            block.inputEnabled = true;
            block.input.enableDrag();
            block.events.onDragStart.add(select);
            block.events.onDragStop.add(released);

            blocksArray.push(block);
        }
    }

    //create the timers
    timer = game.time.create(false);
    timer.start();

    //create events
    //game.input.onUp.add(mouseDragEnd, this); //on mouse release
    //timer.loop(100, dropTiles, this); //ever 200mil seconds drop the blocks 
}

var currentSelectedBlockPos = {x: 0, y: 0};
var currentSelectedBlock = null;
function select(block){
   block.bringToTop();

    currentSelectedBlock = block;
    currentSelectedBlockPos.x = block.x;
    currentSelectedBlockPos.y = block.y;

    var mouseX = game.input.activePointer.worldX;
    var mouseY = game.input.activePointer.worldY;

    block.x = mouseX;
    block.y = mouseY;  
}
function released(block){
    block.x = currentSelectedBlockPos.x;
    block.y = currentSelectedBlockPos.y;
    currentSelectedBlock = null;
    testAllForMatches();
    testAllForDrops();
}
function blockOverlapOccur(block){
    var backupPos = {x: block.x, y: block.y};
    block.x = currentSelectedBlockPos.x;
    block.y = currentSelectedBlockPos.y;

    currentSelectedBlockPos = backupPos;
    swapArrayElements(blocksArray, blocksArray.indexOf(block), blocksArray.indexOf(currentSelectedBlock));
}
function testBlockOverlap(callBack, block)
{   
    if(block){
        for (var i = 0; i < blocksArray.length; ++i){

            var testBlock = blocksArray[i];

            if ((blocksArray[i] != block)){
                var blockCircle = new Phaser.Circle(block.x + (block.width/2), block.y + (block.height/2), 32);
                var testCircle = new Phaser.Circle(testBlock.x + (testBlock.width/2), testBlock.y + (testBlock.height/2), blockSize);
                if (Phaser.Circle.intersects(blockCircle, testCircle))
                    callBack(blocksArray[i]);
            }
        }
    }
    return false;
}

function testAllForMatches(){
    for (var i = 0; i < blocksArray.length; ++i){
        var block = blocksArray[i];
        var matches = testBlockForMatches(block);

        if (matches.horizonal.length >= 3) {
            for (var j = 0; j < matches.horizonal.length; ++j)
                matches.horizonal[j].frame = 0;
        }
        if (matches.vertical.length >= 3) {
            for (var j = 0; j < matches.vertical.length; ++j)
                matches.vertical[j].frame = 0;
        }
    }
}

///////////
// test a block for matches and return them in  
// matches object
function testBlockForMatches(block) {
    var matches = {horizonal: [block], vertical: [block]};

    for (var j = 0; j <= 3; ++j){
        testBlock = getAdjacentBlock(j, block);
        while (testBlock) {
            if (testBlock.frame == block.frame){
                if (j == 0 || j == 2) //Vertical Match
                    matches.vertical.push(testBlock);
                else
                    matches.horizonal.push(testBlock);
                //Get the next test block
                testBlock = getAdjacentBlock(j, testBlock);
            }
            else {
                //No Match break out
                break;
            }
        }
    }

    return matches;
}

function testAllForDrops() {
    var emptyBlocks = true;
    var tweens = [];

    //Drop the remaing Blocks
    for (x = 0; x < blocksWide; x++) {
        for (y = blocksHigh-1; y >= 0 ; y--) {
            //Look bottom to top for empty blocks and move any as low as posible
            block = blocksArray[( y * blocksWide) + x];
            if (block.frame != 0){
                blockBelow = getAdjacentBlock(2, block);
                var originalBlockPos = {x: block.x, y: block.y};
                while(blockBelow && blockBelow.frame == 0){
                    var blockPos = {x: block.x, y: block.y};
                    var blockBelowPos = {x: blockBelow.x, y: blockBelow.y};
                    swapArrayElements(blocksArray, blocksArray.indexOf(block), blocksArray.indexOf(blockBelow));
                    blockBelow.x = blockPos.x;
                    blockBelow.y = blockPos.y;
                    block.x = blockBelowPos.x;
                    block.y = blockBelowPos.y;
                    
                    blockBelow = getAdjacentBlock(2, block);
                }
                if (block.y != originalBlockPos.y) {
                    block.inputEnabled = false;
                    tween = game.add.tween(block).from( { y:  originalBlockPos.y}, 1000, Phaser.Easing.Bounce.Out, false);
                    tween.onComplete.add(function(block){ 
                            block.inputEnabled = true;
                    });
                    tweens.push(tween);
                }
            }
        }
    }

    //set any empty blocks to a random frame and drop from a hight
    for (x = 0; x < blocksWide; x++) {
        for (y = blocksHigh-1; y >= 0 ; y--) {
            block = blocksArray[( y * blocksWide) + x];
            if (block.frame == 0){
                block.frame = randomBlocks.integerInRange(1,5);
                block.inputEnabled = false;
                tween = game.add.tween(block).from( { y:  block.y - 200}, 2000, Phaser.Easing.Bounce.Out, false);
                tween.onComplete.add(function(block){ 
                    block.inputEnabled = true;
                });
                tweens.push(tween);
            }

        }
    }

    for (i = 0; i < tweens.length; i++){
        tweens[i].start();
    }
}

//var 

////////
// get adjacent blocks based on a direction code.
// 0 up. 1 right. 2 down. 3 left. 
//
function getAdjacentBlock(directionCode, block){
    var index = blocksArray.indexOf(block);
    var x = (index % blocksWide);
    var y = parseInt((index / blocksWide));

    if (directionCode == 0 && (y-1 >= 0)) {  //Up 
        return blocksArray[( (y-1) * blocksWide) + x];
    }
    else if (directionCode == 1 && (x+1 < blocksWide)) { // Right
        return blocksArray[(y * blocksWide) + (x+1)];
    }
    else if (directionCode == 2 && (y+1 < blocksHigh)) { //Down
        return blocksArray[((y+1) * blocksWide) + (x)];
    }
    else if (directionCode == 3 && (x-1 >= 0)) { //Left
        return blocksArray[(y * blocksWide) + (x-1)];
    }
    else {
        return null;
    }
}

//////
// Phasers Update function Called every update
//
function update() {
    var mouseX = game.input.activePointer.worldX;
    var mouseY = game.input.activePointer.worldY;
    
    
    testBlockOverlap(blockOverlapOccur, currentSelectedBlock);
    

    

}

/////
// Phasers Render fuction called every draw
//
function render() {
    //draw frame IDs 
    for (var i = 0; i < blocksArray.length; ++i){
        blocksArray[i].tint = 0xffffff;
        game.debug.text(blocksArray.indexOf(blocksArray[i]), blocksArray[i].x+10, blocksArray[i].y+15, '#ffffff' ,'10px Courier');   
        game.debug.text(blocksArray[i].frame, blocksArray[i].x+28, blocksArray[i].y+35, '#ffffff' ,'14px Courier');     
        game.debug.text(i + ": " + blocksArray[i].x + ", " + blocksArray[i].y, 500, 15*i + 20);
    }
}

/////
// Used to swap the array elements
//
function swapArrayElements(array_object, index_a, index_b) {
    var temp = array_object[index_a];
    array_object[index_a] = array_object[index_b];
    array_object[index_b] = temp;
 }


</script>

</body>
</html>